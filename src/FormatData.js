export default function FormatData(weatherData) {
  function getCurrentWeatherImperial() {
    const currentWeather = weatherData.current;
    return {
      city: weatherData.location.name,
      country: weatherData.location.country,
      time: new Date(weatherData.location.localtime_epoch * 1000),
      condition: currentWeather.condition,
      tempF: currentWeather.temp_f,
      feelsLikeF: currentWeather.feelslike_f,
      windKph: currentWeather.wind_kph,
      windDir: currentWeather.wind_dir,
      humidity: currentWeather.humidity,
      precipMm: currentWeather.precip_mm,
    };
  }

  function getCurrentWeatherMetric() {
    const currentWeather = weatherData.current;
    return {
      city: weatherData.location.name,
      country: weatherData.location.country,
      time: new Date(weatherData.location.localtime_epoch * 1000),
      condition: currentWeather.condition,
      tempC: currentWeather.temp_c,
      feelsLikeC: currentWeather.feelslike_c,
      windKph: currentWeather.wind_kph,
      windDir: currentWeather.wind_dir,
      humidity: currentWeather.humidity,
      precipMm: currentWeather.precip_mm,
    };
  }

  function getForecastImperial() {
    const forecast = [];
    weatherData.forecast.forecastday.forEach((forecastDay) => {
      const hours = [];
      forecastDay.hour.forEach((h) => {
        const hour = {
          time: new Date(h.time_epoch * 1000),
          tempF: h.temp_f,
          condition: h.condition,
          windMph: h.wind_mph,
          windDir: h.wind_dir,
          precipIn: h.precip_in,
          humidity: h.humidity,
          feelsLikeF: h.feelslike_f,
        };
        hours.push(hour);
      });

      const astro = {
        sunrise: forecastDay.astro.sunrise,
        sunset: forecastDay.astro.sunset,
        moonrise: forecastDay.astro.moonrise,
        moonset: forecastDay.astro.moonset,
        moonPhase: forecastDay.astro.moon_phase,
        moonIllumination: forecastDay.astro.moon_illumination,
      };

      const day = {
        date: new Date(forecastDay.date_epoch * 1000),
        hours,
        astro,
        maxTempF: forecastDay.day.maxtemp_f,
        minTempF: forecastDay.day.mintemp_f,
        avgTempF: forecastDay.day.avgtemp_f,
        maxWindMph: forecastDay.day.maxwind_mph,
        totalPrecipIn: forecastDay.day.totalprecip_in,
        avgHumidity: forecastDay.day.avghumidity,
        condition: forecastDay.day.condition,
      };

      forecast.push(day);
    });
    return forecast;
  }

  function getForecastMetric() {
    const forecast = [];
    weatherData.forecast.forecastday.forEach((forecastDay) => {
      const hours = [];
      forecastDay.hour.forEach((h) => {
        const hour = {
          time: new Date(h.time_epoch * 1000),
          tempC: h.temp_c,
          condition: h.condition,
          windKph: h.wind_kph,
          windDir: h.wind_dir,
          precipMm: h.precip_mm,
          humidity: h.humidity,
          feelsLikeC: h.feelslike_c,
        };
        hours.push(hour);
      });

      const astro = {
        sunrise: forecastDay.astro.sunrise,
        sunset: forecastDay.astro.sunset,
        moonrise: forecastDay.astro.moonrise,
        moonset: forecastDay.astro.moonset,
        moonPhase: forecastDay.astro.moon_phase,
        moonIllumination: forecastDay.astro.moon_illumination,
      };

      const day = {
        date: new Date(forecastDay.date_epoch * 1000),
        hours,
        astro,
        maxTempC: forecastDay.day.maxtemp_c,
        minTempC: forecastDay.day.mintemp_c,
        avgTempC: forecastDay.day.avgtemp_c,
        maxWindKph: forecastDay.day.maxwind_kph,
        totalPrecipMm: forecastDay.day.totalprecip_mm,
        avgHumidity: forecastDay.day.avghumidity,
        condition: forecastDay.day.condition,
      };

      forecast.push(day);
    });
    return forecast;
  }

  return {
    getCurrentWeatherImperial,
    getCurrentWeatherMetric,
    getForecastImperial,
    getForecastMetric,
  };
}
